/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.writer.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.writer.sdk.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;


public class FullTermWithUser {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("approvedTermExtension")
    private Optional<? extends ApprovedTermExtension> approvedTermExtension;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backlinkedTerms")
    private Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms;

    @JsonProperty("caseSensitive")
    private boolean caseSensitive;

    @JsonProperty("createdUser")
    private TerminologyUser createdUser;

    @JsonProperty("creationTime")
    private OffsetDateTime creationTime;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<? extends String> description;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("examples")
    private Optional<? extends java.util.List<TermExample>> examples;

    @JsonProperty("highlight")
    private boolean highlight;

    @JsonProperty("id")
    private long id;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("linkedTerms")
    private Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mistakes")
    private Optional<? extends java.util.List<TermMistake>> mistakes;

    @JsonProperty("modificationTime")
    private OffsetDateTime modificationTime;

    @JsonProperty("modifiedUser")
    private TerminologyUser modifiedUser;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pos")
    private Optional<? extends FullTermWithUserPos> pos;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tags")
    private Optional<? extends java.util.List<TermTagResponse>> tags;

    @JsonProperty("term")
    private String term;

    @JsonProperty("termBankId")
    private long termBankId;

    @JsonProperty("type")
    private Type type;

    @JsonCreator
    public FullTermWithUser(
            @JsonProperty("approvedTermExtension") Optional<? extends ApprovedTermExtension> approvedTermExtension,
            @JsonProperty("backlinkedTerms") Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms,
            @JsonProperty("caseSensitive") boolean caseSensitive,
            @JsonProperty("createdUser") TerminologyUser createdUser,
            @JsonProperty("creationTime") OffsetDateTime creationTime,
            @JsonProperty("description") Optional<? extends String> description,
            @JsonProperty("examples") Optional<? extends java.util.List<TermExample>> examples,
            @JsonProperty("highlight") boolean highlight,
            @JsonProperty("id") long id,
            @JsonProperty("linkedTerms") Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms,
            @JsonProperty("mistakes") Optional<? extends java.util.List<TermMistake>> mistakes,
            @JsonProperty("modificationTime") OffsetDateTime modificationTime,
            @JsonProperty("modifiedUser") TerminologyUser modifiedUser,
            @JsonProperty("pos") Optional<? extends FullTermWithUserPos> pos,
            @JsonProperty("tags") Optional<? extends java.util.List<TermTagResponse>> tags,
            @JsonProperty("term") String term,
            @JsonProperty("termBankId") long termBankId,
            @JsonProperty("type") Type type) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        Utils.checkNotNull(backlinkedTerms, "backlinkedTerms");
        Utils.checkNotNull(caseSensitive, "caseSensitive");
        Utils.checkNotNull(createdUser, "createdUser");
        Utils.checkNotNull(creationTime, "creationTime");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(examples, "examples");
        Utils.checkNotNull(highlight, "highlight");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        Utils.checkNotNull(mistakes, "mistakes");
        Utils.checkNotNull(modificationTime, "modificationTime");
        Utils.checkNotNull(modifiedUser, "modifiedUser");
        Utils.checkNotNull(pos, "pos");
        Utils.checkNotNull(tags, "tags");
        Utils.checkNotNull(term, "term");
        Utils.checkNotNull(termBankId, "termBankId");
        Utils.checkNotNull(type, "type");
        this.approvedTermExtension = approvedTermExtension;
        this.backlinkedTerms = backlinkedTerms;
        this.caseSensitive = caseSensitive;
        this.createdUser = createdUser;
        this.creationTime = creationTime;
        this.description = description;
        this.examples = examples;
        this.highlight = highlight;
        this.id = id;
        this.linkedTerms = linkedTerms;
        this.mistakes = mistakes;
        this.modificationTime = modificationTime;
        this.modifiedUser = modifiedUser;
        this.pos = pos;
        this.tags = tags;
        this.term = term;
        this.termBankId = termBankId;
        this.type = type;
    }
    
    public FullTermWithUser(
            boolean caseSensitive,
            TerminologyUser createdUser,
            OffsetDateTime creationTime,
            boolean highlight,
            long id,
            OffsetDateTime modificationTime,
            TerminologyUser modifiedUser,
            String term,
            long termBankId,
            Type type) {
        this(Optional.empty(), Optional.empty(), caseSensitive, createdUser, creationTime, Optional.empty(), Optional.empty(), highlight, id, Optional.empty(), Optional.empty(), modificationTime, modifiedUser, Optional.empty(), Optional.empty(), term, termBankId, type);
    }

    @JsonIgnore
    public Optional<? extends ApprovedTermExtension> approvedTermExtension() {
        return approvedTermExtension;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms() {
        return backlinkedTerms;
    }

    @JsonIgnore
    public boolean caseSensitive() {
        return caseSensitive;
    }

    @JsonIgnore
    public TerminologyUser createdUser() {
        return createdUser;
    }

    @JsonIgnore
    public OffsetDateTime creationTime() {
        return creationTime;
    }

    @JsonIgnore
    public Optional<? extends String> description() {
        return description;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermExample>> examples() {
        return examples;
    }

    @JsonIgnore
    public boolean highlight() {
        return highlight;
    }

    @JsonIgnore
    public long id() {
        return id;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms() {
        return linkedTerms;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermMistake>> mistakes() {
        return mistakes;
    }

    @JsonIgnore
    public OffsetDateTime modificationTime() {
        return modificationTime;
    }

    @JsonIgnore
    public TerminologyUser modifiedUser() {
        return modifiedUser;
    }

    @JsonIgnore
    public Optional<? extends FullTermWithUserPos> pos() {
        return pos;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermTagResponse>> tags() {
        return tags;
    }

    @JsonIgnore
    public String term() {
        return term;
    }

    @JsonIgnore
    public long termBankId() {
        return termBankId;
    }

    @JsonIgnore
    public Type type() {
        return type;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public FullTermWithUser withApprovedTermExtension(ApprovedTermExtension approvedTermExtension) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        this.approvedTermExtension = Optional.ofNullable(approvedTermExtension);
        return this;
    }

    public FullTermWithUser withApprovedTermExtension(Optional<? extends ApprovedTermExtension> approvedTermExtension) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        this.approvedTermExtension = approvedTermExtension;
        return this;
    }

    public FullTermWithUser withBacklinkedTerms(java.util.List<FullLinkedTerm> backlinkedTerms) {
        Utils.checkNotNull(backlinkedTerms, "backlinkedTerms");
        this.backlinkedTerms = Optional.ofNullable(backlinkedTerms);
        return this;
    }

    public FullTermWithUser withBacklinkedTerms(Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms) {
        Utils.checkNotNull(backlinkedTerms, "backlinkedTerms");
        this.backlinkedTerms = backlinkedTerms;
        return this;
    }

    public FullTermWithUser withCaseSensitive(boolean caseSensitive) {
        Utils.checkNotNull(caseSensitive, "caseSensitive");
        this.caseSensitive = caseSensitive;
        return this;
    }

    public FullTermWithUser withCreatedUser(TerminologyUser createdUser) {
        Utils.checkNotNull(createdUser, "createdUser");
        this.createdUser = createdUser;
        return this;
    }

    public FullTermWithUser withCreationTime(OffsetDateTime creationTime) {
        Utils.checkNotNull(creationTime, "creationTime");
        this.creationTime = creationTime;
        return this;
    }

    public FullTermWithUser withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    public FullTermWithUser withDescription(Optional<? extends String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    public FullTermWithUser withExamples(java.util.List<TermExample> examples) {
        Utils.checkNotNull(examples, "examples");
        this.examples = Optional.ofNullable(examples);
        return this;
    }

    public FullTermWithUser withExamples(Optional<? extends java.util.List<TermExample>> examples) {
        Utils.checkNotNull(examples, "examples");
        this.examples = examples;
        return this;
    }

    public FullTermWithUser withHighlight(boolean highlight) {
        Utils.checkNotNull(highlight, "highlight");
        this.highlight = highlight;
        return this;
    }

    public FullTermWithUser withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public FullTermWithUser withLinkedTerms(java.util.List<FullLinkedTerm> linkedTerms) {
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        this.linkedTerms = Optional.ofNullable(linkedTerms);
        return this;
    }

    public FullTermWithUser withLinkedTerms(Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms) {
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        this.linkedTerms = linkedTerms;
        return this;
    }

    public FullTermWithUser withMistakes(java.util.List<TermMistake> mistakes) {
        Utils.checkNotNull(mistakes, "mistakes");
        this.mistakes = Optional.ofNullable(mistakes);
        return this;
    }

    public FullTermWithUser withMistakes(Optional<? extends java.util.List<TermMistake>> mistakes) {
        Utils.checkNotNull(mistakes, "mistakes");
        this.mistakes = mistakes;
        return this;
    }

    public FullTermWithUser withModificationTime(OffsetDateTime modificationTime) {
        Utils.checkNotNull(modificationTime, "modificationTime");
        this.modificationTime = modificationTime;
        return this;
    }

    public FullTermWithUser withModifiedUser(TerminologyUser modifiedUser) {
        Utils.checkNotNull(modifiedUser, "modifiedUser");
        this.modifiedUser = modifiedUser;
        return this;
    }

    public FullTermWithUser withPos(FullTermWithUserPos pos) {
        Utils.checkNotNull(pos, "pos");
        this.pos = Optional.ofNullable(pos);
        return this;
    }

    public FullTermWithUser withPos(Optional<? extends FullTermWithUserPos> pos) {
        Utils.checkNotNull(pos, "pos");
        this.pos = pos;
        return this;
    }

    public FullTermWithUser withTags(java.util.List<TermTagResponse> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = Optional.ofNullable(tags);
        return this;
    }

    public FullTermWithUser withTags(Optional<? extends java.util.List<TermTagResponse>> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = tags;
        return this;
    }

    public FullTermWithUser withTerm(String term) {
        Utils.checkNotNull(term, "term");
        this.term = term;
        return this;
    }

    public FullTermWithUser withTermBankId(long termBankId) {
        Utils.checkNotNull(termBankId, "termBankId");
        this.termBankId = termBankId;
        return this;
    }

    public FullTermWithUser withType(Type type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FullTermWithUser other = (FullTermWithUser) o;
        return 
            java.util.Objects.deepEquals(this.approvedTermExtension, other.approvedTermExtension) &&
            java.util.Objects.deepEquals(this.backlinkedTerms, other.backlinkedTerms) &&
            java.util.Objects.deepEquals(this.caseSensitive, other.caseSensitive) &&
            java.util.Objects.deepEquals(this.createdUser, other.createdUser) &&
            java.util.Objects.deepEquals(this.creationTime, other.creationTime) &&
            java.util.Objects.deepEquals(this.description, other.description) &&
            java.util.Objects.deepEquals(this.examples, other.examples) &&
            java.util.Objects.deepEquals(this.highlight, other.highlight) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.linkedTerms, other.linkedTerms) &&
            java.util.Objects.deepEquals(this.mistakes, other.mistakes) &&
            java.util.Objects.deepEquals(this.modificationTime, other.modificationTime) &&
            java.util.Objects.deepEquals(this.modifiedUser, other.modifiedUser) &&
            java.util.Objects.deepEquals(this.pos, other.pos) &&
            java.util.Objects.deepEquals(this.tags, other.tags) &&
            java.util.Objects.deepEquals(this.term, other.term) &&
            java.util.Objects.deepEquals(this.termBankId, other.termBankId) &&
            java.util.Objects.deepEquals(this.type, other.type);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            approvedTermExtension,
            backlinkedTerms,
            caseSensitive,
            createdUser,
            creationTime,
            description,
            examples,
            highlight,
            id,
            linkedTerms,
            mistakes,
            modificationTime,
            modifiedUser,
            pos,
            tags,
            term,
            termBankId,
            type);
    }
    
    @Override
    public String toString() {
        return Utils.toString(FullTermWithUser.class,
                "approvedTermExtension", approvedTermExtension,
                "backlinkedTerms", backlinkedTerms,
                "caseSensitive", caseSensitive,
                "createdUser", createdUser,
                "creationTime", creationTime,
                "description", description,
                "examples", examples,
                "highlight", highlight,
                "id", id,
                "linkedTerms", linkedTerms,
                "mistakes", mistakes,
                "modificationTime", modificationTime,
                "modifiedUser", modifiedUser,
                "pos", pos,
                "tags", tags,
                "term", term,
                "termBankId", termBankId,
                "type", type);
    }
    
    public final static class Builder {
 
        private Optional<? extends ApprovedTermExtension> approvedTermExtension = Optional.empty();
 
        private Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms = Optional.empty();
 
        private Boolean caseSensitive;
 
        private TerminologyUser createdUser;
 
        private OffsetDateTime creationTime;
 
        private Optional<? extends String> description = Optional.empty();
 
        private Optional<? extends java.util.List<TermExample>> examples = Optional.empty();
 
        private Boolean highlight;
 
        private Long id;
 
        private Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms = Optional.empty();
 
        private Optional<? extends java.util.List<TermMistake>> mistakes = Optional.empty();
 
        private OffsetDateTime modificationTime;
 
        private TerminologyUser modifiedUser;
 
        private Optional<? extends FullTermWithUserPos> pos = Optional.empty();
 
        private Optional<? extends java.util.List<TermTagResponse>> tags = Optional.empty();
 
        private String term;
 
        private Long termBankId;
 
        private Type type;  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder approvedTermExtension(ApprovedTermExtension approvedTermExtension) {
            Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
            this.approvedTermExtension = Optional.ofNullable(approvedTermExtension);
            return this;
        }

        public Builder approvedTermExtension(Optional<? extends ApprovedTermExtension> approvedTermExtension) {
            Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
            this.approvedTermExtension = approvedTermExtension;
            return this;
        }

        public Builder backlinkedTerms(java.util.List<FullLinkedTerm> backlinkedTerms) {
            Utils.checkNotNull(backlinkedTerms, "backlinkedTerms");
            this.backlinkedTerms = Optional.ofNullable(backlinkedTerms);
            return this;
        }

        public Builder backlinkedTerms(Optional<? extends java.util.List<FullLinkedTerm>> backlinkedTerms) {
            Utils.checkNotNull(backlinkedTerms, "backlinkedTerms");
            this.backlinkedTerms = backlinkedTerms;
            return this;
        }

        public Builder caseSensitive(boolean caseSensitive) {
            Utils.checkNotNull(caseSensitive, "caseSensitive");
            this.caseSensitive = caseSensitive;
            return this;
        }

        public Builder createdUser(TerminologyUser createdUser) {
            Utils.checkNotNull(createdUser, "createdUser");
            this.createdUser = createdUser;
            return this;
        }

        public Builder creationTime(OffsetDateTime creationTime) {
            Utils.checkNotNull(creationTime, "creationTime");
            this.creationTime = creationTime;
            return this;
        }

        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        public Builder description(Optional<? extends String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        public Builder examples(java.util.List<TermExample> examples) {
            Utils.checkNotNull(examples, "examples");
            this.examples = Optional.ofNullable(examples);
            return this;
        }

        public Builder examples(Optional<? extends java.util.List<TermExample>> examples) {
            Utils.checkNotNull(examples, "examples");
            this.examples = examples;
            return this;
        }

        public Builder highlight(boolean highlight) {
            Utils.checkNotNull(highlight, "highlight");
            this.highlight = highlight;
            return this;
        }

        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder linkedTerms(java.util.List<FullLinkedTerm> linkedTerms) {
            Utils.checkNotNull(linkedTerms, "linkedTerms");
            this.linkedTerms = Optional.ofNullable(linkedTerms);
            return this;
        }

        public Builder linkedTerms(Optional<? extends java.util.List<FullLinkedTerm>> linkedTerms) {
            Utils.checkNotNull(linkedTerms, "linkedTerms");
            this.linkedTerms = linkedTerms;
            return this;
        }

        public Builder mistakes(java.util.List<TermMistake> mistakes) {
            Utils.checkNotNull(mistakes, "mistakes");
            this.mistakes = Optional.ofNullable(mistakes);
            return this;
        }

        public Builder mistakes(Optional<? extends java.util.List<TermMistake>> mistakes) {
            Utils.checkNotNull(mistakes, "mistakes");
            this.mistakes = mistakes;
            return this;
        }

        public Builder modificationTime(OffsetDateTime modificationTime) {
            Utils.checkNotNull(modificationTime, "modificationTime");
            this.modificationTime = modificationTime;
            return this;
        }

        public Builder modifiedUser(TerminologyUser modifiedUser) {
            Utils.checkNotNull(modifiedUser, "modifiedUser");
            this.modifiedUser = modifiedUser;
            return this;
        }

        public Builder pos(FullTermWithUserPos pos) {
            Utils.checkNotNull(pos, "pos");
            this.pos = Optional.ofNullable(pos);
            return this;
        }

        public Builder pos(Optional<? extends FullTermWithUserPos> pos) {
            Utils.checkNotNull(pos, "pos");
            this.pos = pos;
            return this;
        }

        public Builder tags(java.util.List<TermTagResponse> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = Optional.ofNullable(tags);
            return this;
        }

        public Builder tags(Optional<? extends java.util.List<TermTagResponse>> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = tags;
            return this;
        }

        public Builder term(String term) {
            Utils.checkNotNull(term, "term");
            this.term = term;
            return this;
        }

        public Builder termBankId(long termBankId) {
            Utils.checkNotNull(termBankId, "termBankId");
            this.termBankId = termBankId;
            return this;
        }

        public Builder type(Type type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }
        
        public FullTermWithUser build() {
            return new FullTermWithUser(
                approvedTermExtension,
                backlinkedTerms,
                caseSensitive,
                createdUser,
                creationTime,
                description,
                examples,
                highlight,
                id,
                linkedTerms,
                mistakes,
                modificationTime,
                modifiedUser,
                pos,
                tags,
                term,
                termBankId,
                type);
        }
    }
}

