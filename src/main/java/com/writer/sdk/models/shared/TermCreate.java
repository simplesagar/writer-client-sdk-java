/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.writer.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.writer.sdk.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class TermCreate {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("approvedTermExtension")
    private Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension;

    @JsonProperty("caseSensitive")
    private boolean caseSensitive;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<? extends String> description;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("examples")
    private Optional<? extends java.util.List<TermExampleCreate>> examples;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("highlight")
    private Optional<? extends Boolean> highlight;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("linkedTerms")
    private Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mistakes")
    private Optional<? extends java.util.List<TermMistakeCreate>> mistakes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pos")
    private Optional<? extends TermCreatePos> pos;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private Optional<? extends String> reference;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tags")
    private Optional<? extends java.util.List<TermTagCreate>> tags;

    @JsonProperty("term")
    private String term;

    @JsonProperty("type")
    private TermCreateType type;

    @JsonCreator
    public TermCreate(
            @JsonProperty("approvedTermExtension") Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension,
            @JsonProperty("caseSensitive") boolean caseSensitive,
            @JsonProperty("description") Optional<? extends String> description,
            @JsonProperty("examples") Optional<? extends java.util.List<TermExampleCreate>> examples,
            @JsonProperty("highlight") Optional<? extends Boolean> highlight,
            @JsonProperty("linkedTerms") Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms,
            @JsonProperty("mistakes") Optional<? extends java.util.List<TermMistakeCreate>> mistakes,
            @JsonProperty("pos") Optional<? extends TermCreatePos> pos,
            @JsonProperty("reference") Optional<? extends String> reference,
            @JsonProperty("tags") Optional<? extends java.util.List<TermTagCreate>> tags,
            @JsonProperty("term") String term,
            @JsonProperty("type") TermCreateType type) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        Utils.checkNotNull(caseSensitive, "caseSensitive");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(examples, "examples");
        Utils.checkNotNull(highlight, "highlight");
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        Utils.checkNotNull(mistakes, "mistakes");
        Utils.checkNotNull(pos, "pos");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(tags, "tags");
        Utils.checkNotNull(term, "term");
        Utils.checkNotNull(type, "type");
        this.approvedTermExtension = approvedTermExtension;
        this.caseSensitive = caseSensitive;
        this.description = description;
        this.examples = examples;
        this.highlight = highlight;
        this.linkedTerms = linkedTerms;
        this.mistakes = mistakes;
        this.pos = pos;
        this.reference = reference;
        this.tags = tags;
        this.term = term;
        this.type = type;
    }
    
    public TermCreate(
            boolean caseSensitive,
            String term,
            TermCreateType type) {
        this(Optional.empty(), caseSensitive, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), term, type);
    }

    @JsonIgnore
    public Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension() {
        return approvedTermExtension;
    }

    @JsonIgnore
    public boolean caseSensitive() {
        return caseSensitive;
    }

    @JsonIgnore
    public Optional<? extends String> description() {
        return description;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermExampleCreate>> examples() {
        return examples;
    }

    @JsonIgnore
    public Optional<? extends Boolean> highlight() {
        return highlight;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms() {
        return linkedTerms;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermMistakeCreate>> mistakes() {
        return mistakes;
    }

    @JsonIgnore
    public Optional<? extends TermCreatePos> pos() {
        return pos;
    }

    @JsonIgnore
    public Optional<? extends String> reference() {
        return reference;
    }

    @JsonIgnore
    public Optional<? extends java.util.List<TermTagCreate>> tags() {
        return tags;
    }

    @JsonIgnore
    public String term() {
        return term;
    }

    @JsonIgnore
    public TermCreateType type() {
        return type;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public TermCreate withApprovedTermExtension(ApprovedTermExtensionCreate approvedTermExtension) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        this.approvedTermExtension = Optional.ofNullable(approvedTermExtension);
        return this;
    }

    public TermCreate withApprovedTermExtension(Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension) {
        Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
        this.approvedTermExtension = approvedTermExtension;
        return this;
    }

    public TermCreate withCaseSensitive(boolean caseSensitive) {
        Utils.checkNotNull(caseSensitive, "caseSensitive");
        this.caseSensitive = caseSensitive;
        return this;
    }

    public TermCreate withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    public TermCreate withDescription(Optional<? extends String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    public TermCreate withExamples(java.util.List<TermExampleCreate> examples) {
        Utils.checkNotNull(examples, "examples");
        this.examples = Optional.ofNullable(examples);
        return this;
    }

    public TermCreate withExamples(Optional<? extends java.util.List<TermExampleCreate>> examples) {
        Utils.checkNotNull(examples, "examples");
        this.examples = examples;
        return this;
    }

    public TermCreate withHighlight(boolean highlight) {
        Utils.checkNotNull(highlight, "highlight");
        this.highlight = Optional.ofNullable(highlight);
        return this;
    }

    public TermCreate withHighlight(Optional<? extends Boolean> highlight) {
        Utils.checkNotNull(highlight, "highlight");
        this.highlight = highlight;
        return this;
    }

    public TermCreate withLinkedTerms(java.util.List<LinkedTermCreate> linkedTerms) {
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        this.linkedTerms = Optional.ofNullable(linkedTerms);
        return this;
    }

    public TermCreate withLinkedTerms(Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms) {
        Utils.checkNotNull(linkedTerms, "linkedTerms");
        this.linkedTerms = linkedTerms;
        return this;
    }

    public TermCreate withMistakes(java.util.List<TermMistakeCreate> mistakes) {
        Utils.checkNotNull(mistakes, "mistakes");
        this.mistakes = Optional.ofNullable(mistakes);
        return this;
    }

    public TermCreate withMistakes(Optional<? extends java.util.List<TermMistakeCreate>> mistakes) {
        Utils.checkNotNull(mistakes, "mistakes");
        this.mistakes = mistakes;
        return this;
    }

    public TermCreate withPos(TermCreatePos pos) {
        Utils.checkNotNull(pos, "pos");
        this.pos = Optional.ofNullable(pos);
        return this;
    }

    public TermCreate withPos(Optional<? extends TermCreatePos> pos) {
        Utils.checkNotNull(pos, "pos");
        this.pos = pos;
        return this;
    }

    public TermCreate withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = Optional.ofNullable(reference);
        return this;
    }

    public TermCreate withReference(Optional<? extends String> reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    public TermCreate withTags(java.util.List<TermTagCreate> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = Optional.ofNullable(tags);
        return this;
    }

    public TermCreate withTags(Optional<? extends java.util.List<TermTagCreate>> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = tags;
        return this;
    }

    public TermCreate withTerm(String term) {
        Utils.checkNotNull(term, "term");
        this.term = term;
        return this;
    }

    public TermCreate withType(TermCreateType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TermCreate other = (TermCreate) o;
        return 
            java.util.Objects.deepEquals(this.approvedTermExtension, other.approvedTermExtension) &&
            java.util.Objects.deepEquals(this.caseSensitive, other.caseSensitive) &&
            java.util.Objects.deepEquals(this.description, other.description) &&
            java.util.Objects.deepEquals(this.examples, other.examples) &&
            java.util.Objects.deepEquals(this.highlight, other.highlight) &&
            java.util.Objects.deepEquals(this.linkedTerms, other.linkedTerms) &&
            java.util.Objects.deepEquals(this.mistakes, other.mistakes) &&
            java.util.Objects.deepEquals(this.pos, other.pos) &&
            java.util.Objects.deepEquals(this.reference, other.reference) &&
            java.util.Objects.deepEquals(this.tags, other.tags) &&
            java.util.Objects.deepEquals(this.term, other.term) &&
            java.util.Objects.deepEquals(this.type, other.type);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            approvedTermExtension,
            caseSensitive,
            description,
            examples,
            highlight,
            linkedTerms,
            mistakes,
            pos,
            reference,
            tags,
            term,
            type);
    }
    
    @Override
    public String toString() {
        return Utils.toString(TermCreate.class,
                "approvedTermExtension", approvedTermExtension,
                "caseSensitive", caseSensitive,
                "description", description,
                "examples", examples,
                "highlight", highlight,
                "linkedTerms", linkedTerms,
                "mistakes", mistakes,
                "pos", pos,
                "reference", reference,
                "tags", tags,
                "term", term,
                "type", type);
    }
    
    public final static class Builder {
 
        private Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension = Optional.empty();
 
        private Boolean caseSensitive;
 
        private Optional<? extends String> description = Optional.empty();
 
        private Optional<? extends java.util.List<TermExampleCreate>> examples = Optional.empty();
 
        private Optional<? extends Boolean> highlight = Optional.empty();
 
        private Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms = Optional.empty();
 
        private Optional<? extends java.util.List<TermMistakeCreate>> mistakes = Optional.empty();
 
        private Optional<? extends TermCreatePos> pos = Optional.empty();
 
        private Optional<? extends String> reference = Optional.empty();
 
        private Optional<? extends java.util.List<TermTagCreate>> tags = Optional.empty();
 
        private String term;
 
        private TermCreateType type;  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder approvedTermExtension(ApprovedTermExtensionCreate approvedTermExtension) {
            Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
            this.approvedTermExtension = Optional.ofNullable(approvedTermExtension);
            return this;
        }

        public Builder approvedTermExtension(Optional<? extends ApprovedTermExtensionCreate> approvedTermExtension) {
            Utils.checkNotNull(approvedTermExtension, "approvedTermExtension");
            this.approvedTermExtension = approvedTermExtension;
            return this;
        }

        public Builder caseSensitive(boolean caseSensitive) {
            Utils.checkNotNull(caseSensitive, "caseSensitive");
            this.caseSensitive = caseSensitive;
            return this;
        }

        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        public Builder description(Optional<? extends String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        public Builder examples(java.util.List<TermExampleCreate> examples) {
            Utils.checkNotNull(examples, "examples");
            this.examples = Optional.ofNullable(examples);
            return this;
        }

        public Builder examples(Optional<? extends java.util.List<TermExampleCreate>> examples) {
            Utils.checkNotNull(examples, "examples");
            this.examples = examples;
            return this;
        }

        public Builder highlight(boolean highlight) {
            Utils.checkNotNull(highlight, "highlight");
            this.highlight = Optional.ofNullable(highlight);
            return this;
        }

        public Builder highlight(Optional<? extends Boolean> highlight) {
            Utils.checkNotNull(highlight, "highlight");
            this.highlight = highlight;
            return this;
        }

        public Builder linkedTerms(java.util.List<LinkedTermCreate> linkedTerms) {
            Utils.checkNotNull(linkedTerms, "linkedTerms");
            this.linkedTerms = Optional.ofNullable(linkedTerms);
            return this;
        }

        public Builder linkedTerms(Optional<? extends java.util.List<LinkedTermCreate>> linkedTerms) {
            Utils.checkNotNull(linkedTerms, "linkedTerms");
            this.linkedTerms = linkedTerms;
            return this;
        }

        public Builder mistakes(java.util.List<TermMistakeCreate> mistakes) {
            Utils.checkNotNull(mistakes, "mistakes");
            this.mistakes = Optional.ofNullable(mistakes);
            return this;
        }

        public Builder mistakes(Optional<? extends java.util.List<TermMistakeCreate>> mistakes) {
            Utils.checkNotNull(mistakes, "mistakes");
            this.mistakes = mistakes;
            return this;
        }

        public Builder pos(TermCreatePos pos) {
            Utils.checkNotNull(pos, "pos");
            this.pos = Optional.ofNullable(pos);
            return this;
        }

        public Builder pos(Optional<? extends TermCreatePos> pos) {
            Utils.checkNotNull(pos, "pos");
            this.pos = pos;
            return this;
        }

        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = Optional.ofNullable(reference);
            return this;
        }

        public Builder reference(Optional<? extends String> reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }

        public Builder tags(java.util.List<TermTagCreate> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = Optional.ofNullable(tags);
            return this;
        }

        public Builder tags(Optional<? extends java.util.List<TermTagCreate>> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = tags;
            return this;
        }

        public Builder term(String term) {
            Utils.checkNotNull(term, "term");
            this.term = term;
            return this;
        }

        public Builder type(TermCreateType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }
        
        public TermCreate build() {
            return new TermCreate(
                approvedTermExtension,
                caseSensitive,
                description,
                examples,
                highlight,
                linkedTerms,
                mistakes,
                pos,
                reference,
                tags,
                term,
                type);
        }
    }
}

